from enum import Enum
import numpy as np
import cupy as cp
import random
import pytest
import qutip
import qutip.core.data as _data
from qutip.tests.core.data.conftest import (
    random_csr, random_dense, random_diag
)
from qutip_cuquantum.state import CuState
from qutip_cuquantum.operator import CuOperator, ProdTerm, Term
from qutip_cuquantum.utils import Transform

cudense = pytest.importorskip("cuquantum.densitymat")

class StateType(Enum):
    """Enumeration for quantum state types."""
    KET = 1      # Pure state, column vector (N, 1)
    BRA = 2      # Pure state, row vector (1, N)
    DM = 3       # Density matrix (N, N)


def random_pure_custate(hilbert):
    """Generate a random `CuPyDense` matrix with the given shape."""
    N = abs(np.prod(hilbert))
    out = (
        np.random.rand(N, 1) + 1j * np.random.rand(N, 1)
    ).astype(cp.complex128)
    out = qutip.core.data.Dense(out)
    return CuState(out, hilbert, copy=False)


def random_mixed_custate(hilbert):
    """Generate a random `CuPyDense` matrix with the given shape."""
    N = abs(np.prod(hilbert))
    out = (
        np.random.rand(N, N) + 1j * np.random.rand(N, N)
    ).astype(cp.complex128)
    out = qutip.core.data.Dense(out)
    return CuState(out, hilbert, copy=False)


def random_custate(shape):
    *hilbert, state_type = shape
    
    if isinstance(state_type, int):
        # Special handling for shapes generated by generate_scalar_is_ket in TestInner
        if(state_type == 1):
            state_type = StateType.KET
        else:
            raise ValueError(f"Unsupported state type: {state_type}")
    
    if state_type == StateType.KET:
        return random_pure_custate(hilbert)
    elif state_type == StateType.DM:
        return random_mixed_custate(hilbert)
    elif state_type == StateType.BRA:
        ket_state = random_pure_custate(hilbert)
        return CuState(ket_state.base, shape=(ket_state.shape[1], ket_state.shape[0]), copy=False)
    else:
        raise ValueError(f"Unsupported state type: {state_type}")


def _rand_transform(gen):
    """
    Random transform between raw, dag, T, conj, with bias toward common cases.
    """
    return gen.choice(list(Transform), p=[0.4, 0.15, 0.15, 0.3])


def _rand_elementary_oper(size, gen):
    """
    Generate a random elementary operator for CuOperator construction.
    
    Handles weak modes (negative hilbert dimensions) by checking size > 0
    and using abs(size) for array dimensions.
    """
    if gen.uniform() < 0.5 and size > 0:
        # 50% Dia format
        mat = random_diag((size, size), gen.uniform()*0.4, False, gen)
    elif gen.uniform() < 0.6:
        # 30% Dense format
        mat = random_dense((abs(size), abs(size)), gen.uniform() > 0.5, gen)
    else:
        # 20% CSR format (not fully supported, converted to dense eventually)
        mat = random_csr((abs(size), abs(size)), gen.uniform()*0.4, False, gen)

    if gen.uniform() < 0.5 and size > 0:
        # Use cuDensity format instead of qutip.
        array_type = np if gen.uniform() < 0.5 else cp
        if isinstance(mat, _data.Dia):
            dia_matrix = mat.as_scipy()
            offsets = list(dia_matrix.offsets)
            data = array_type.zeros(
                (dia_matrix.shape[0], len(offsets)),
                dtype=complex,
            )
            for i, offset in enumerate(offsets):
                end = None if offset == 0 else -abs(offset)
                data[:end, i] = array_type.asarray( dia_matrix.diagonal(offset) )
            mat = cudense.MultidiagonalOperator(data, offsets)

        else:
            mat = cudense.DenseOperator(array_type.array(mat.to_array()))

    return mat


def random_CuOperator(hilbert_dims, N_elementary, seed):
    """
    Generate a random `CuOperator` matrix with the given hilbert_dims.
    
    Parameters
    ----------
    hilbert_dims : tuple
        Hilbert space dimensions for each mode. Negative values indicate weak modes.
    N_elementary : list of int
        List specifying number of elementary operators per term.
    seed : int
        Random seed for reproducibility.
    
    Returns
    -------
    CuOperator
        A random CuOperator with the specified structure.
    """
    generator = np.random.default_rng(seed)
    out = CuOperator(hilbert_dims=hilbert_dims)
    for N in N_elementary:
        term = Term([], generator.normal() + 1j * generator.normal())
        for _ in range(N):
            mode = np.random.randint(len(hilbert_dims))
            size = hilbert_dims[mode]
            oper = _rand_elementary_oper(size, generator)

            term.prod_terms.append(ProdTerm(oper, (mode,), _rand_transform(generator)))
        out.terms.append(term)
    return out


def cases_cuoperator(hilbert):
    """
    Generate a set of test cases for CuOperator with various complexities.
    
    Parameters
    ----------
    hilbert : tuple
        Hilbert space dimensions.
    
    Returns
    -------
    list of pytest.param
        Test cases with different operator structures.
    """
    def factory(N_elementary, seed):
        return lambda: random_CuOperator(hilbert, N_elementary, seed)

    cases = []

    cases.append(pytest.param(factory([], 0), id="zero"))
    cases.append(pytest.param(factory([0], 0), id="id"))
    seed = random.randint(0, 2**31)
    cases.append(pytest.param(factory([1], seed), id=f"simple_{seed}"))
    seed = random.randint(0, 2**31)
    cases.append(pytest.param(factory([3], seed), id=f"3_prods_{seed}"))
    seed = random.randint(0, 2**31)
    cases.append(pytest.param(factory([1, 1, 1], seed), id=f"3_terms_{seed}"))
    seed = random.randint(0, 2**31)
    cases.append(pytest.param(factory([1, 2, 3], seed), id=f"complex_{seed}"))

    return cases
